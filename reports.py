"""
reports.py
------------
Lightweight PDF/CSV exports using matplotlib only (no extra deps).

Exports:
- build_options_report_pdf(...): returns PDF bytes for European options summary
- build_bond_report_pdf(...): returns PDF bytes for Fixed-Income bond summary
- build_metrics_csv(...): returns CSV bytes for a flat dict of metrics
"""

from __future__ import annotations
from io import BytesIO
from typing import Dict, Optional
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from matplotlib.backends.backend_pdf import PdfPages

from bs_core import OptionInput, bs_prices, bs_greeks


# -------------------------------------------------------------------------
# --- Figure builders (shared between Options and Bonds) ------------------
# -------------------------------------------------------------------------
def _figure_title_page(title: str, subtitle: str) -> plt.Figure:
    fig = plt.figure(figsize=(8.3, 11.7))  # A4 portrait
    fig.text(0.5, 0.7, title, ha="center", va="center", fontsize=28, weight="bold")
    fig.text(0.5, 0.62, subtitle, ha="center", va="center", fontsize=12, color="#444")
    fig.text(0.5, 0.12, "Generated by Pricer", ha="center", va="center", fontsize=10, color="#777")
    return fig


def _figure_key_values_table(title: str, kv: Dict[str, str]) -> plt.Figure:
    fig, ax = plt.subplots(figsize=(8.3, 5.8))
    ax.axis("off")
    ax.set_title(title, fontsize=16, pad=12)
    rows = [[k, v] for k, v in kv.items()]
    table = ax.table(cellText=rows, colLabels=["Metric", "Value"], loc="center")
    table.auto_set_font_size(False)
    table.set_fontsize(10)
    table.scale(1.1, 1.3)
    return fig


def _figure_smile_plot(S0_eff: float, r: float, q: float, T: float, sigma_seed: float, K_center: float) -> plt.Figure:
    Ks = np.linspace(max(0.01, K_center * 0.5), K_center * 1.5, 50)
    prices_c, prices_p = [], []
    for K in Ks:
        oi = OptionInput(S0=S0_eff, K=float(K), r=r, sigma=sigma_seed, T=T, q=q)
        c, p, *_ = bs_prices(oi)
        prices_c.append(c)
        prices_p.append(p)
    fig, ax = plt.subplots(figsize=(8.3, 4.2))
    ax.plot(Ks, prices_c, label="Call (BS)", linewidth=1.5)
    ax.plot(Ks, prices_p, label="Put (BS)", linewidth=1.5)
    ax.axvline(K_center, linestyle="--", linewidth=1)
    ax.set_xlabel("Strike (K)")
    ax.set_ylabel("Option value")
    ax.set_title("Option value vs Strike at current σ")
    ax.legend()
    return fig


def _figure_curve(curve_df: Optional[pd.DataFrame]) -> Optional[plt.Figure]:
    if curve_df is None or curve_df.empty:
        return None
    fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(8.3, 3.8))
    try:
        ax1.plot(curve_df["T"], curve_df["Zero(%)"], marker="o")
        ax1.set_title("Zero (Spot) Curve")
        ax1.set_xlabel("T (years)")
        ax1.set_ylabel("Zero (%)")

        ax2.plot(curve_df["T"], curve_df["DF"], marker="o")
        ax2.set_title("Discount Factors")
        ax2.set_xlabel("T (years)")
        ax2.set_ylabel("DF")
    except Exception:
        plt.close(fig)
        return None
    return fig


# -------------------------------------------------------------------------
# --- OPTIONS REPORT ------------------------------------------------------
# -------------------------------------------------------------------------
def build_options_report_pdf(
    *,
    S0: float,
    S0_eff: float,
    K: float,
    r: float,
    q: float,
    T: float,
    sigma: float,
    opt_type: str,
    valuation_date_str: str,
    curve_df: Optional[pd.DataFrame] = None,
) -> bytes:
    """Compose multi-page Options PDF: Title, Inputs, Prices/Greeks, Smile, Curve."""
    oi = OptionInput(S0=S0_eff, K=K, r=r, sigma=sigma, T=T, q=q)
    call, put, d1, d2 = bs_prices(oi)
    G = bs_greeks(oi)

    inputs = {
        "Valuation date": valuation_date_str,
        "Option type": opt_type.capitalize(),
        "Spot S₀": f"{S0:,.4f}",
        "Effective spot S₀,eff": f"{S0_eff:,.4f}",
        "Strike K": f"{K:,.4f}",
        "Time to expiry T (yrs)": f"{T:.6f}",
        "r (cont., % p.a.)": f"{r*100:.4f}%",
        "q (cont., % p.a.)": f"{q*100:.4f}%",
        "Volatility σ (% p.a.)": f"{sigma*100:.4f}%",
    }

    prices = {
        "Call price (BS)": f"{call:,.6f}",
        "Put price (BS)": f"{put:,.6f}",
        "d₁": f"{d1:.6f}",
        "d₂": f"{d2:.6f}",
    }

    greeks = {
        "Delta (Call)": f"{G['delta']['call']:.6f}",
        "Delta (Put)": f"{G['delta']['put']:.6f}",
        "Gamma": f"{G['gamma']:.6f}",
        "Vega (per 1% σ)": f"{G['vega_per_1pct']:.6f}",
        "Theta/day (Call)": f"{G['theta_per_day']['call']:.6f}",
        "Theta/day (Put)": f"{G['theta_per_day']['put']:.6f}",
        "Theta/year (Call)": f"{G['theta_per_year']['call']:.6f}",
        "Theta/year (Put)": f"{G['theta_per_year']['put']:.6f}",
        "Rho (Call)": f"{G['rho']['call']:.6f}",
        "Rho (Put)": f"{G['rho']['put']:.6f}",
    }

    buf = BytesIO()
    with PdfPages(buf) as pdf:
        pdf.savefig(_figure_title_page("Options Report", "European (Black–Scholes) • Pricer")); plt.close()
        pdf.savefig(_figure_key_values_table("Inputs", inputs)); plt.close()

        # Prices + Greeks
        fig_pg = plt.figure(figsize=(8.3, 8.3))
        ax1 = fig_pg.add_subplot(2, 1, 1); ax1.axis("off")
        ax1.set_title("Prices", fontsize=14, pad=8)
        tbl1 = ax1.table(cellText=[[k, v] for k, v in prices.items()],
                         colLabels=["Metric", "Value"], loc="center")
        tbl1.auto_set_font_size(False); tbl1.set_fontsize(10); tbl1.scale(1.1, 1.3)

        ax2 = fig_pg.add_subplot(2, 1, 2); ax2.axis("off")
        ax2.set_title("Greeks", fontsize=14, pad=8)
        tbl2 = ax2.table(cellText=[[k, v] for k, v in greeks.items()],
                         colLabels=["Greek", "Value"], loc="center")
        tbl2.auto_set_font_size(False); tbl2.set_fontsize(10); tbl2.scale(1.1, 1.3)
        pdf.savefig(fig_pg); plt.close(fig_pg)

        # Smile plot
        pdf.savefig(_figure_smile_plot(S0_eff, r, q, T, sigma, K)); plt.close()

        # Curve (if provided)
        fig_curve = _figure_curve(curve_df)
        if fig_curve is not None:
            pdf.savefig(fig_curve); plt.close(fig_curve)

    return buf.getvalue()


# -------------------------------------------------------------------------
# --- BOND REPORT ---------------------------------------------------------
# -------------------------------------------------------------------------
def build_bond_report_pdf(
    *,
    face: float,
    coupon_rate: float,
    ytm: float,
    T: float,
    freq: int,
    price: float,
    macaulay_dur: float,
    modified_dur: float,
    convexity: float,
    valuation_date_str: str,
) -> bytes:
    """Compose a Bond Report PDF showing pricing, yields, durations, and convexity."""
    buf = BytesIO()
    with PdfPages(buf) as pdf:
        pdf.savefig(_figure_title_page("Bond Report", "Fixed Income • Pricer")); plt.close()

        # Inputs
        inputs = {
            "Valuation date": valuation_date_str,
            "Face Value": f"{face:,.2f}",
            "Coupon Rate (% p.a.)": f"{coupon_rate*100:.3f}%",
            "Yield-to-Maturity (% p.a.)": f"{ytm*100:.3f}%",
            "Time to Maturity (yrs)": f"{T:.3f}",
            "Coupon Frequency": f"{freq}x per year",
        }
        pdf.savefig(_figure_key_values_table("Inputs", inputs)); plt.close()

        # Results
        results = {
            "Clean Price": f"{price:,.4f}",
            "Macaulay Duration (yrs)": f"{macaulay_dur:,.4f}",
            "Modified Duration (yrs)": f"{modified_dur:,.4f}",
            "Convexity": f"{convexity:,.4f}",
        }
        pdf.savefig(_figure_key_values_table("Results", results)); plt.close()

    return buf.getvalue()


# -------------------------------------------------------------------------
# --- CSV EXPORT ----------------------------------------------------------
# -------------------------------------------------------------------------
def build_metrics_csv(metrics: Dict[str, float | int | str]) -> bytes:
    """Flatten dict to a single-row CSV and return bytes."""
    df = pd.DataFrame([metrics])
    return df.to_csv(index=False).encode("utf-8")
